# Основы Unicode для программистов
**Валерий Ремнев**
### Введение
Настоящая статья адресована программистам, которые не знакомы со стандартом Unicode, но имеют потребность его освоить для применения в своих разработках, включая кодирование и корректное распознавание всевозможных символов, в числе которых алфавиты разных стран, математические, технические, музыкальные, эмодзи и другие специальные знаки.
Обработки текста является востребованной почти для каждой программы, поэтому каждый программист должен хорошо в этом разбираться.
Основным стандартом для преобразования кодовых точек в символы является Unicode [1].
До разработки стандарта Unicode существовало множество 8-битных кодировок, часто несовместимых друг с другом, что создавало проблему преобразования одного кода в другой.
Практически все пользовались стандартом ASCII или подобными стандартами, однако представленные в них наборы символов, их структура и функции сильно ограничены и недостаточны для выполнения современных программных разработок.
Unicode не только лишен перечисленных выше недостатков, но и допускает развитие, включая добавление новых символов (в том числе, составных) и целых областей.
С момента появления первой версии стандарта в 1991 году он постоянно развивается и дополняется.
В настоящее время он содержит основные системы письма всего мира: порядка 1100 языков уже поддерживается и еще планируется добавить около 100 языков.
Тем самым Unicode расширяет возможности разрабатываемых приложений, а также увеличивает их «тиражирование» по всему миру и, следовательно, коммерческую ценность.

### 1. Основные принципы Unicode
В Unicode каждой букве (знаку) ставится в соответствие **кодовая точка**, состоящая из префикса U+ и числа в шестнадцатеричном формате, например: U+004D: Latin Capital Letter M.	
Множество всех возможных кодовых точек называется **кодовым пространством** [2].
Кодовое пространство принято делить на плоскости из 65636 кодовых точек каждая. Всего таких плоскостей 17. Их наглядная графическая иллюстрация представлена в работе [3].
Назначенные кодовые точки распределены, в основном, в первых трех плоскостях.
Нулевая плоскость (**Базовая многоязычная плоскость, BMP**) содержит практически все символы современного текста в любом шрифте.
Плоскости 1 и 2 содержат древние языки и символы. В плоскости 14 представлен ряд символов форматирования. Остальные плоскости свободны, в том числе, плоскости 15-16 зарезервированы для частного использования.
Стандарт Unicode содержит 2 раздела: **UCS** (**Universal Character Set** – универсальный набор символов) и **UTF** (**Unicode Transformation Format** – семейство кодировок).
UCS устанавливает соответствие символов кодовым точкам, а UTF – соответствие кодовых точек машинным кодам (байтам).
Кодовые точки представляются в памяти компьютера в виде байтов.
Кодировки **UTF-8**, **UTF-16** и **UTF-32** состоят, соответственно их 8-битных, 16-битных и 32-битных блоков.
Наиболее часто используются UTF-8 или UTF-16.
Каждой кодовой точке может соответствовать несколько машинных представлений (кодировок).
Это аналогично механизму инкапсуляции в ООП, когда одному интерфейсу соответствует несколько программных реализаций.
Кодовые точки для различных букв и знаков можно найти, например, используя утилиту Windows *charmap*. Здесь данные представлены в виде наборов символов (шрифтов). Указав курсором на выбранный символ, определяем его кодовую точку.
В Unicode предусмотрена система для динамического составления символов, когда один символ может быть представлен объединением нескольких кодовых точек.
Это применяется в европейских языках при использовании диакритических знаков с буквами, в слоговых алфавитах японского и ряда других языков, иероглифах, различных математических и технических знаках. Для одной буквы могут использоваться сразу несколько **диакритических знаков** [4], например, две точки, точка и макрон и др.
Для определения эквивалентности строк в Unicode применяются **формы нормализации**, приведенные в таблице 1 [5].
#### Таблица 1. Формы нормализации 
Форма	     |Описание
:--------------------------|:-------------------------
Normalization Form D (NFD) |	Каноническая декомпозиция
Normalization Form C (NFC) |	Каноническая декомпозиция с последующей канонической композицией
Normalization Form KD(NFKD)|	Декомпозиция совместимости
Normalization Form KC(NFKC)|	Композиция совместимости с последующей канонической композицией
**Нормализация** представляет собой преобразование строк к одной из форм нормализации. Затем осуществляется двоичное сравнение строк.

### 2. Ключевые различия между UTF-8 и UTF-16	
Для успешного применения кодировок UTF-8 и UTF-16 необходимо знать их преимущества и недостатки.
В UTF-8 для хранения кодовых точек в диапазоне от 0 до 127 используется 1 байт, от 128 и выше – от 2 до 4 байт для соответствующих диапазонов. При этом старшие биты каждого байта используются в качестве двоичных префиксов, обозначающих одиночный байт, начало последовательности байтов или ее продолжение, как показано в таблице [3]:
UTF-8 (двоичный код) |Кодовая точка (двоичное представление) |Диапазон
:----------------------------------|:------------------------|:-------------------
0xxxxxxx|xxxxxxx|U+0000–U+007F
110xxxxx 10yyyyyy|xxxxxyyyyyy|U+0080–U+07FF
1110xxxx 10yyyyyy 10zzzzzz|xxxxyyyyyyzzzzzz|U+0800–U+FFFF
11110xxx 10yyyyyy 10zzzzzz 10wwwwww|xxxyyyyyyzzzzzzwwwwww|U+10000–U+10FFFF
Следовательно, в UTF-8 осуществляется оптимизация хранения кодовых точек, что является важнейшим его преимуществом.
Другим полезным свойством UTF-8 является то, что кодовые точки ниже 128 кодируются, как и  символы ASCII, одиночными байтами, что позволяет расширять унаследованные ASCII-программы и API для обработки строк UTF-8.
Недостатком является то, что UTF-8 не является полной заменой строк ASCII, поскольку, например, код, который измеряет длину строки, должен будет декодировать UTF-8 и перебирать кодовые точки, а не байты.
UTF-16 использует 16-битные слова: 1-2 слова в зависимости от диапазона (соответственно U+0000–U+FFFF или U+10000–U+10FFFF).
В кодовом пространстве UTF-16  первые 65 536 позиций отображаются как 16-битные числа. 
Исключением является интервал U+D800…U+DFFF, который, совместно с интервалом U+D800…U+DBFF используется для формирования так называемых «суррогатных пар» - символов, которые кодируются двумя 16-битными словами с целью обеспечения возможности использования структуры Char, когда  символ занимает более двух байтов.
### 3. Рекомендации по применению Unicode
Для работы с текстом программисту, в первую очередь, нужно выяснить, в какой кодировке представлена та или иная строка. Это требуется для правильного ее распознавания и отображения.
В сообщениях электронной почты для явного указания кодировки в заголовке используется строка вида [3]: 
**Content-type: text/plain; charset=”UTF-8”**.
Аналогичный подход применяется для веб-страницы.
При отсутствии информации о кодировке веб-браузер может использовать гистограммы частот появления различных байтов в тех или иных языках. Однако такой подход полностью проблемы не решает.
В настоящее время разработан ряд программ - онлайн-декодеров - для определения кодировки файла и перекодировки его в другой формат [6]. Для выполнения этих действий в работе [7] автор использует класс InputStreamReader Java и приводит примеры  кода программы.
В общем случае, в языках программирования связь с Unicode обеспечивается через типы данных, константы и методы. Например, в языке C для UTF-8, UTF-16 и UTF-32 основными типами являются char, char16_t и char32_t соответственно.
В языке Java есть только один символьный тип - char - 16-разрядное беззнаковое целое, представляющее собой символ UTF-16.
Кроме того, в  Java включены методы для работы с кодировками [8]:
- *availableCharsets* – для получения списка всех кодировок в Java;
- *defaultCharset* – для получения текущей активной кодировки;
- методы для преодразования строки в массив байт;
- методы для преобразования набора байт из одной кодировки в другую;
- методы для преобразования набора байт из файла в строку (при известной кодировке в файле) и др.
Для работы с составными символами, которые сформированы из нескольких кодовых точек, в Java имеется класс **java.text.BreakIterator** [9].
Он реализует методы для определения расположения границ в тексте.
Экземпляры BreakIterator просматривают текст и возвращают индекс символов, где встречаются границы.
BreakIterator использует для сканирования *CharacterIterator*.
Рекомендуется применять модули *getWordIterator, getLineIterator*, *getSentenceIterator* и *getCharacterIterator* для анализа, соответственно, границ слов, строк, предложений и символов.
Эти модули могут использоваться для редактирования текста.
В работе [9] приведен ряд полезных примеров применения BreakIterator в Java:
- для создания и использования текстовых страниц;
- для печати каждого элемента строки по порядку;
- для печати каждого элемента в обратном порядке;
- для печати первого и последнего элементов строки;
- для печати элемента в указанной позиции.
Подобный набор средств манипулирования текстом имеется в большинстве современных языков программирования.
При этом знакомство со стандартом Unicode, способами кодирования и функциями позволяет программистам обоснованно и эффективно применять эти возможности в своих разработках.
### Список источников
1. Unicode 12.1.0. May 7, 2019. (http://www.unicode.org/versions/Unicode12.1.0/)
2. Joel Spolsky. The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!).  October  8, 2003. (https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)
3. Nathan Reed. A Programmer’s Introduction to Unicode. March 3, 2017. (http://reedbeta.com/blog/programmers-intro-to-unicode/)
4. Ю.Б. Коряков. Диакритические знаки. (https://bigenc.ru/linguistics/text/1954362)
5. http://unicode.org/reports/tr15/#Norm_Forms
6. https://www.kakprosto.ru/kak-68671-kak-opredelit-kodirovku-fayla
7. https://habr.com/ru/post/315374/
8. https://javarush.ru/quests/lectures/questmultithreading.level02.lecture10
9. https://web.mit.edu/java/java_v1.1.6/www/api/java.text.BreakIterator.html 

















   

  
